from flask import Flask, jsonify, request
import os
import time
import json
import pandas as pd
from pickle import load
from datetime import datetime
import re
from collections import defaultdict
# let's load the most recent predictions, generated by the daily dag, in memory to be very quickly referencable during production
# start by indicating the domains for which we DO have latest predictions generated
domains_with_latest_predictions = ['pressgazette', 'citymonitor', 'investmentmonitor', 'energymonitor', 'techmonitor',
                  'monitors', 'elitetraveler', 'newstatesman']

# then, load the dataframes in a list of tuples, to easily identify and call the dataframes during runtime
loaded_predictions = [(pd.read_csv(f'/home/airflow_gcp/segmentation/latest_segments/{domain}_latest_pred.csv'),
                      domain) for domain in domains_with_latest_predictions]

# add a list of the domains for which we have a randomforest classifier for realtime prediction fit and deployed
domains_with_rf = ['pressgazette', 'citymonitor', 'investmentmonitor', 'energymonitor', 'techmonitor',
                  'monitors', 'elitetraveler', 'newstatesman']
# to identify random forest fits
random_state = 0

# similar as the files above - we need to load the encoders and models to be easily accessible for the realtime prediction
loaded_encoders = [(load(open(f'/home/airflow_gcp/segmentation/{domain}/{domain}_encoder_rs{random_state}.pkl', 'rb')),
                    domain) for domain in domains_with_rf]
loaded_models = [(load(open(f'/home/airflow_gcp/segmentation/{domain}/rf_classifier_{domain}_rs{random_state}.sav', 'rb')),
                    domain) for domain in domains_with_rf]

# define a function to take up an hour (0-24, UTC) and a continent as string, and return a localized hour
def localize_hour(utc_hour, continent):
    if continent == 'North America':
        local_hour = utc_hour - 6
    elif continent == 'South America':
        local_hour = utc_hour - 3
    elif continent == 'Europe':
        local_hour = utc_hour + 1
    elif continent == 'Africa':
        local_hour = utc_hour + 1
    elif continent == 'Asia':
        local_hour = utc_hour + 5
    else:
        local_hour = utc_hour
    return local_hour

# define a method to identify whether a referrer belongs to any of the groups below
def extract_referrer_group(referrer, domain):
    social_list = ['facebook', 'linkedin', 'twitter', 't.co/', 'youtube', 'instagram', 'reddit', 'pinterest']
    search_list = ['ask', 'baidu', 'bing', 'duckduckgo', 'google', 'yahoo', 'yandex']
    nsmg_network = ['energymonitor.ai', 'investmentmonitor.ai', 'citymonitor.ai', 'newstatesman.com',
                   'cbronline.com', 'techmonitor.ai', 'elitetraveler.com']
    own_website = [domain]
    email = ['Pardot', 'pardot']
    if any(wildcard in referrer for wildcard in social_list):
        referrer_group = 'social'
    elif any(wildcard in referrer for wildcard in search_list):
        referrer_group = 'search'
    elif any(wildcard in referrer for wildcard in nsmg_network):
        referrer_group = 'NSMG'
    elif any(wildcard in referrer for wildcard in own_website):
        referrer_group = 'own_website'
    elif any(wildcard in referrer for wildcard in email):
        referrer_group = 'email'
    else:
        referrer_group = 'other_referrer'
    return referrer_group

# define a method to identify whether the user_agent belongs to any of the groups below
def extract_os_group(user_agent):
    if 'Mozilla/5.0 (Linux' in user_agent:
        os_group = 'linux'
    elif 'Mozilla/5.0 (Android' in user_agent:
        os_group = 'android'
    elif 'Mozilla/5.0 (Windows NT 10.0' in user_agent:
        os_group = 'windows10'
    elif 'Mozilla/5.0 (Windows' in user_agent and 'Mozilla/5.0 (Windows NT 10.0' not in user_agent:
        os_group = 'windows_older'
    elif 'Mozilla/5.0 (iPhone' in user_agent:
        os_group = 'iphone'
    elif 'Mozilla/5.0 (Macintosh' in user_agent:
        os_group = 'macintosh'
    elif 'Mozilla/5.0 AppleWebKit' in user_agent:
        os_group = 'apple_other'
    else:
        os_group = 'other_os'
    return os_group

# define a method to receive the data sent by the caller of the api, and predict a user's cluster in real time
def predict_user_cluster(domain, continent, referrer, user_agent, encoder, model):
    # start by cleaning the timestamp into a locallized hour
    utc_timestamp_now = datetime.utcnow().hour
    locallized_hour = localize_hour(utc_timestamp_now, continent)
    # make sure the referrer is not None; TODO: logic might be broken here..
    if referrer is None:
        referrer = 'other'
    # extract the referrer group
    referrer_group = extract_referrer_group(referrer, domain)
    # extract the os group
    os_group = extract_os_group(user_agent)
    # create a dataframe with a single row to contain the data of the call we received
    df_to_pred = pd.DataFrame([domain, continent, locallized_hour, referrer_group, os_group]).transpose()
    df_to_pred.columns = ['domain', 'continent', 'local_hour_proxy', 'referrer_group', 'os_group']
    # push the categorical columns to the encoder received as parameter by the method
    categorical_df_to_pred = df_to_pred[['domain', 'continent', 'referrer_group', 'os_group']]
    ohe_array_to_pred = encoder.transform(categorical_df_to_pred)
    oh_df_to_pred = pd.DataFrame(ohe_array_to_pred,
                                 index = categorical_df_to_pred.index, columns = encoder.get_feature_names())
    # finally, join to the non-categorical data
    transformed_df = oh_df_to_pred.join(df_to_pred[['local_hour_proxy']])
    # call the .predict method of the model
    prediction = model.predict(transformed_df)
    return prediction[0]

app = Flask(__name__)
# decorate the method
@app.route('/segmentation_service', methods=['POST', 'GET'])
# function to parse get request and return results
def extract():
    # variable to hold any error messages
    status = {}
    # list of continents
    lst_continents = ['North America','South America','Europe','Africa','Asia','Antarctica','Australia']

    # check request type
    if request.method == 'POST':
        # parse request
        request_json = request.get_json()
        if 'token' in request_json.keys():
        	token_request = request_json['token']
        	if token_request == 'MbRbb7UqUZOjnIeqOEV0-m_dQ4g':
                if 'domain' in request_json.keys():
                    # get the domain
                    domain_request = request_json['domain']
                    if domain_request not in domains_with_rf:
                        status[domain_request] = "The provided domain is not in the predefined domains list. Please use one from the list: 'pressgazette', 'citymonitor', 'investmentmonitor', 'energymonitor', 'techmonitor', 'monitors', 'elitetraveler', 'newstatesman'" 
                else:
                    status['domain'] = "Parameter 'domain' is not provided."
                # get the user_id
                if 'user_id' in request_json.keys():
                    user_id_request = request_json['user_id']
                    ALPHANUM=re.compile('^[a-zA-Z0-9_.-]+$')
                    if ALPHANUM.match(user_id_request) is None:
                        status[user_id_request] = "The provided user id is in invalid format."
                else:
                    status['user_id'] = "Parameter 'user_id' is not provided."
                if 'continent' in request_json.keys():
                    # get the other parameters
                    continent_request = request_json['continent']
                    if continent_request not in lst_continents:
                        status[continent_request] = "The provided continent is invalid. Please use one of the list: 'North America','South America','Europe','Africa','Asia','Antarctica','Australia'"
                else:
                    status['continent'] = "Parameter 'continent' is not provided."
                if 'referrer'  in request_json.keys():
                    referrer_request = request_json['referrer']
                else:
                    status['referrer'] = "Parameter 'referrer' is not provided."
                if 'user_agent'  in request_json.keys():    
                    user_agent_request = request_json['user_agent']
                else:
                    status['user_agent'] = "Parameter 'user_agent' is not provided."
                if status:
                    return jsonify(status)
                # check the user's segment from the respective domain's latest predictions
                domain_file_list = [item[0] for item in loaded_predictions if item[1] == domain_request]
                assert len(domain_file_list) == 1
                domain_file = domain_file_list[0]
                segment_row = domain_file[domain_file['user_id'] == user_id_request]
                # see if the dataframe is empty
                if segment_row.shape[0] == 0:
                    # if there's no such user in the data, check whether we have a fit realtime classifier for the domain
                    if domain_request in domains_with_rf:
                        # if so, get the encoder and the model by identifying on the second item in the tuples
                        encoder_list = [item[0] for item in loaded_encoders if item[1] == domain_request]
                        assert len(encoder_list) == 1
                        encoder = encoder_list[0]
                        model_list = [item[0] for item in loaded_models if item[1] == domain_request]
                        assert len(model_list) == 1
                        model = model_list[0]
                        # call the predict method defined above
                        segment = predict_user_cluster(domain_request, continent_request, referrer_request,
                                                       user_agent_request, encoder, model)
                        # make sure this prediction is distinguishable to the actual cluster associations on the latest dag predictions
                        segment = str(f'Soft prediction: {segment}')
                    else:
                        segment = "placeholder for now..."
                else:
                    # otherwise, return user's segment
                    assert segment_row.shape[0] == 1
                    segment = str(segment_row['cluster'].values[0])
                results = segment
            else:
                results = "Please provide a valid 'token' parameter."
        else:
            results = "Please provide a 'token' parameter."
    else:
        results = 'This API only works with POST requests.'
    return jsonify(results)
              
if __name__ == '__main__':
    #run the app on port 10_002 on the local machine
    app.run(host='0.0.0.0', port=10002, debug=False)